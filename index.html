<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>炎と水のアニメーション - ブラー効果付き</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            touch-action: manipulation;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>
    <div id="instructions">画面をタップして炎と水を切り替え</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // シーンの設定
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        // カメラの設定
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        
        // レンダラーの設定
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // テクスチャローダーの作成
        const textureLoader = new THREE.TextureLoader();
        
        // パーティクルテクスチャの作成（ブラー効果用）
        function createCircleTexture(color, size) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // キャンバスサイズを設定（大きいほどブラーの質が向上）
            canvas.width = 128;
            canvas.height = 128;
            
            // グラデーションの作成
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = size * 32; // ブラーの強さを調整
            
            const gradient = ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius
            );
            
            // 透明のグラデーションを設定
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.4, color.replace('1.0)', '0.5)'));
            gradient.addColorStop(1, color.replace('1.0)', '0.0)'));
            
            // 円を描画
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // テクスチャを作成
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // テクスチャの作成
        const fireTexture = createCircleTexture('rgba(255, 150, 0, 1.0)', 1.0);
        const waterTexture = createCircleTexture('rgba(30, 150, 255, 1.0)', 1.0);
        const smokeTexture = createCircleTexture('rgba(200, 200, 200, 1.0)', 1.2);
        
        // 光源の設定
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const fireLight = new THREE.PointLight(0xff7700, 1, 10);
        fireLight.position.set(0, 0, 2);
        scene.add(fireLight);
        
        // 炎のパーティクルシステム
        const particleCount = 300;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
            // 初期位置
            positions[i * 3] = (Math.random() - 0.5) * 2;
            positions[i * 3 + 1] = Math.random() * 2 - 1;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
            
            // 炎の色（赤から黄色）
            colors[i * 3] = Math.random() * 0.5 + 0.5; // 赤
            colors[i * 3 + 1] = Math.random() * 0.3; // 緑
            colors[i * 3 + 2] = 0; // 青
            
            // パーティクルのサイズ（大きめに設定）
            sizes[i] = Math.random() * 0.4 + 0.2;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        // パーティクルマテリアル（テクスチャを使用）
        const particleMaterial = new THREE.PointsMaterial({
            size: 0.3,
            map: fireTexture,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
            sizeAttenuation: true
        });
        
        // パーティクルシステムの作成
        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        
        // 煙のパーティクルシステム
        const smokeCount = 150;
        const smokeParticles = new THREE.BufferGeometry();
        const smokePositions = new Float32Array(smokeCount * 3);
        const smokeColors = new Float32Array(smokeCount * 3);
        const smokeSizes = new Float32Array(smokeCount);
        
        for (let i = 0; i < smokeCount; i++) {
            smokePositions[i * 3] = (Math.random() - 0.5) * 3;
            smokePositions[i * 3 + 1] = Math.random() * 3 + 1;
            smokePositions[i * 3 + 2] = (Math.random() - 0.5) * 3;
            
            // 煙の色（灰色）
            smokeColors[i * 3] = 0.6; // 赤
            smokeColors[i * 3 + 1] = 0.6; // 緑
            smokeColors[i * 3 + 2] = 0.6; // 青
            
            smokeSizes[i] = Math.random() * 0.5 + 0.3;
        }
        
        smokeParticles.setAttribute('position', new THREE.BufferAttribute(smokePositions, 3));
        smokeParticles.setAttribute('color', new THREE.BufferAttribute(smokeColors, 3));
        smokeParticles.setAttribute('size', new THREE.BufferAttribute(smokeSizes, 1));
        
        const smokeMaterial = new THREE.PointsMaterial({
            size: 0.5,
            map: smokeTexture,
            vertexColors: true,
            transparent: true,
            opacity: 0,
            depthWrite: false,
            sizeAttenuation: true
        });
        
        const smokeSystem = new THREE.Points(smokeParticles, smokeMaterial);
        scene.add(smokeSystem);
        
        // 水のパーティクルシステム
        const waterCount = 250;
        const waterParticles = new THREE.BufferGeometry();
        const waterPositions = new Float32Array(waterCount * 3);
        const waterColors = new Float32Array(waterCount * 3);
        const waterSizes = new Float32Array(waterCount);
        
        for (let i = 0; i < waterCount; i++) {
            waterPositions[i * 3] = (Math.random() - 0.5) * 4;
            waterPositions[i * 3 + 1] = Math.random() * 5 + 3;
            waterPositions[i * 3 + 2] = (Math.random() - 0.5) * 4;
            
            // 水の色（青）
            waterColors[i * 3] = 0.1; // 赤
            waterColors[i * 3 + 1] = 0.5 + Math.random() * 0.3; // 緑
            waterColors[i * 3 + 2] = 0.8 + Math.random() * 0.2; // 青
            
            waterSizes[i] = Math.random() * 0.4 + 0.2;
        }
        
        waterParticles.setAttribute('position', new THREE.BufferAttribute(waterPositions, 3));
        waterParticles.setAttribute('color', new THREE.BufferAttribute(waterColors, 3));
        waterParticles.setAttribute('size', new THREE.BufferAttribute(waterSizes, 1));
        
        const waterMaterial = new THREE.PointsMaterial({
            size: 0.4,
            map: waterTexture,
            vertexColors: true,
            transparent: true,
            opacity: 0,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });
        
        const waterSystem = new THREE.Points(waterParticles, waterMaterial);
        scene.add(waterSystem);
        
        // 台座（火元）の作成
        const baseGeometry = new THREE.CylinderGeometry(1, 1.2, 0.5, 32);
        const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = -1.5;
        scene.add(base);
        
        // アニメーションの状態
        let state = 'fire'; // fire, water, smoke
        let transitionTime = 0;
        
        // イベントリスナー
        window.addEventListener('resize', onWindowResize);
        document.addEventListener('click', toggleState);
        document.addEventListener('touchstart', toggleState);
        
        function toggleState() {
            if (state === 'fire') {
                state = 'water';
                transitionTime = 0;
            } else {
                state = 'fire';
                transitionTime = 0;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 炎のアニメーション
        function animateFire() {
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            const sizes = particleSystem.geometry.attributes.size.array;
            
            for (let i = 0; i < particleCount; i++) {
                // 上に移動
                positions[i * 3 + 1] += 0.03 * (Math.random() + 0.5);
                
                // 左右にゆらぐ
                positions[i * 3] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                
                // 炎の先端ほど明るく
                const brightness = positions[i * 3 + 1] / 3 + 0.5;
                colors[i * 3] = Math.min(brightness, 1.0); // 赤
                colors[i * 3 + 1] = Math.min(brightness * 0.7, 0.7); // 緑
                
                // サイズも高さによって変化（先端で小さく）
                const heightRatio = Math.max(0, 1 - positions[i * 3 + 1] / 3);
                sizes[i] = Math.max(0.1, heightRatio * 0.5) + Math.random() * 0.1;
                
                // 一定の高さを超えたら下に戻す
                if (positions[i * 3 + 1] > 3) {
                    positions[i * 3] = (Math.random() - 0.5) * 2;
                    positions[i * 3 + 1] = Math.random() * 0.5 - 1;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
                    sizes[i] = Math.random() * 0.4 + 0.2;
                }
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            particleSystem.geometry.attributes.size.needsUpdate = true;
        }
        
        // 水のアニメーション
        function animateWater() {
            const positions = waterSystem.geometry.attributes.position.array;
            const sizes = waterSystem.geometry.attributes.size.array;
            
            for (let i = 0; i < waterCount; i++) {
                // 下に落ちる
                positions[i * 3 + 1] -= 0.1 * (Math.random() + 1);
                
                // 重力で広がる
                const distance = Math.sqrt(
                    positions[i * 3] * positions[i * 3] + 
                    positions[i * 3 + 2] * positions[i * 3 + 2]
                );
                
                if (distance > 0.1) {
                    positions[i * 3] += positions[i * 3] / distance * 0.01;
                    positions[i * 3 + 2] += positions[i * 3 + 2] / distance * 0.01;
                }
                
                // 落下速度に応じてサイズを伸ばす（細長い水滴の効果）
                const fallSpeed = Math.random() * 0.1 + 0.05;
                sizes[i] = Math.min(0.5, Math.max(0.2, sizes[i] + fallSpeed * 0.05));
                
                // 地面に当たったら消える、または跳ねる
                if (positions[i * 3 + 1] < -1) {
                    if (Math.random() > 0.7) { // 30%の確率で跳ねる
                        positions[i * 3 + 1] = -0.9;
                        positions[i * 3] += (Math.random() - 0.5) * 0.5;
                        positions[i * 3 + 2] += (Math.random() - 0.5) * 0.5;
                        sizes[i] = Math.random() * 0.2 + 0.1; // 跳ねるときは小さく
                    } else { // 消える
                        positions[i * 3 + 1] = Math.random() * 5 + 3;
                        positions[i * 3] = (Math.random() - 0.5) * 4;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 4;
                        sizes[i] = Math.random() * 0.4 + 0.2;
                    }
                }
            }
            
            waterSystem.geometry.attributes.position.needsUpdate = true;
            waterSystem.geometry.attributes.size.needsUpdate = true;
        }
        
        // 煙のアニメーション
        function animateSmoke() {
            const positions = smokeSystem.geometry.attributes.position.array;
            const colors = smokeSystem.geometry.attributes.color.array;
            const sizes = smokeSystem.geometry.attributes.size.array;
            
            for (let i = 0; i < smokeCount; i++) {
                // ゆっくり上昇
                positions[i * 3 + 1] += 0.02 * (Math.random() + 0.2);
                
                // 左右に拡散
                positions[i * 3] += Math.sin(Date.now() * 0.0005 + i) * 0.01;
                positions[i * 3 + 2] += Math.cos(Date.now() * 0.0005 + i) * 0.01;
                
                // 高さに応じて透明に、サイズも大きく
                const alpha = Math.max(0, 1 - (positions[i * 3 + 1] / 5));
                colors[i * 3] = 0.5 * alpha;
                colors[i * 3 + 1] = 0.5 * alpha;
                colors[i * 3 + 2] = 0.5 * alpha;
                
                // 上昇するにつれてサイズを大きく
                sizes[i] = Math.min(1.0, sizes[i] + 0.002);
                
                // 一定の高さを超えたら下に戻す
                if (positions[i * 3 + 1] > 5 || Math.random() > 0.997) {
                    positions[i * 3] = (Math.random() - 0.5) * 3;
                    positions[i * 3 + 1] = Math.random() * 2 - 0.5;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 3;
                    sizes[i] = Math.random() * 0.5 + 0.3;
                }
            }
            
            smokeSystem.geometry.attributes.position.needsUpdate = true;
            smokeSystem.geometry.attributes.color.needsUpdate = true;
            smokeSystem.geometry.attributes.size.needsUpdate = true;
        }
        
        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);
            
            // 炎の揺らぎアニメーション
            if (state === 'fire' || particleMaterial.opacity > 0) {
                animateFire();
            }
            
            // 水のアニメーション
            if (state === 'water' && waterMaterial.opacity > 0) {
                animateWater();
            }
            
            // 煙のアニメーション
            if (smokeMaterial.opacity > 0) {
                animateSmoke();
            }
            
            // 状態遷移のアニメーション
            transitionTime += 0.01;
            if (state === 'fire') {
                // 炎の光を明るく
                fireLight.intensity = Math.min(1.5, transitionTime * 1.5);
                
                // 炎を表示
                particleMaterial.opacity = Math.min(1, transitionTime);
                
                // 水を消す
                waterMaterial.opacity = Math.max(0, 1 - transitionTime * 2);
                
                // 煙を徐々に消す
                smokeMaterial.opacity = Math.max(0, 1 - transitionTime);
            } else if (state === 'water') {
                // 水を表示
                waterMaterial.opacity = Math.min(1, transitionTime);
                
                // 炎を消す
                particleMaterial.opacity = Math.max(0, 1 - transitionTime * 2);
                
                // 煙を表示
                smokeMaterial.opacity = Math.min(0.8, transitionTime);
                
                // 炎の光を暗く
                fireLight.intensity = Math.max(0, 1.5 - transitionTime * 2);
            }
            
            // カメラをゆっくり回転
            camera.position.x = Math.sin(Date.now() * 0.0005) * 5;
            camera.position.z = Math.cos(Date.now() * 0.0005) * 5;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>